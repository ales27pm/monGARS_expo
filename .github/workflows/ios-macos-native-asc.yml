name: iOS (macOS native EAS) + ASC Upload ‚Äî iOS 18.3.1

on:
  workflow_dispatch:
    inputs:
      model_name:
        description: "Model to download and include"
        required: true
        default: "none"
        type: choice
        options: [qwen2-0.5b, llama-3.2-1b, smollm2-1.7b, phi-3-mini, all, none]
      upload_to_testflight:
        description: "Upload .ipa to App Store Connect (TestFlight)"
        type: boolean
        default: true

env:
  APP_NAME: monGARS
  # TODO: replace these when you purge VIBECODE:
  BUNDLE_ID: com.vibecode.offllmappstorefixer-iz6sup
  SCHEME: offLLMAppStoreFixer
  MODELS_DIR: ./assets/models

jobs:
  build-and-upload:
    runs-on: macos-15 # macOS 15 image (Xcode 16.x toolchains)
    permissions:
      contents: write
      pull-requests: write
    timeout-minutes: 90

    steps:
      - name: üì• Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # ---- Select Xcode that supports iOS 18.3.x (tries 16.4 ‚Üí 16.3 ‚Üí 16.2) ----
      - name: üîß Select Xcode (16.4 ‚Üí 16.3 ‚Üí 16.2) & initialize
        id: xcode
        shell: bash
        run: |
          set -euo pipefail
          choose() {
            local P="$1"
            if [ -d "$P" ]; then
              sudo xcode-select -s "$P"
              echo "DEVELOPER_DIR=$P" >> "$GITHUB_ENV"
              echo "selected=$P" >> "$GITHUB_OUTPUT"
              return 0
            fi
            return 1
          }
          if ! choose "/Applications/Xcode_16.4.app/Contents/Developer"; then
            if ! choose "/Applications/Xcode_16.3.app/Contents/Developer"; then
              choose "/Applications/Xcode_16.2.app/Contents/Developer"
            fi
          fi
          echo "Using DEVELOPER_DIR=$(xcode-select -p)"
          sudo xcodebuild -license accept || true
          sudo xcodebuild -runFirstLaunch || true
          xcodebuild -version

      # ---- Ensure iPhoneOS 18.3(.1) SDK is present (device platform) ----
      - name: üß© Ensure iOS 18.3.1 platform is installed
        shell: bash
        run: |
          set -euo pipefail
          echo "SDKs BEFORE:"
          xcodebuild -showsdks || true
          if ! xcodebuild -showsdks | grep -E -q "iphoneos18\.3(\.1)?"; then
            echo "‚ö†Ô∏è iphoneos18.3(.1) not found ‚Äî downloading iOS platform‚Ä¶"
            sudo xcodebuild -downloadPlatform iOS || true
            if ! xcodebuild -showsdks | grep -E -q "iphoneos18\.3(\.1)?"; then
              echo "Fallback: -downloadAllPlatforms‚Ä¶"
              sudo xcodebuild -downloadAllPlatforms || true
            fi
          fi
          echo "SDKs AFTER:"
          xcodebuild -showsdks || true

      # ---- Optional: model downloads (same pattern you used before) ----
      - name: üêç Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: üì¶ Python deps
        if: ${{ inputs.model_name != 'none' }}
        run: pip3 install huggingface-hub requests tqdm

      - name: üìÅ Ensure models dir
        if: ${{ inputs.model_name != 'none' }}
        run: mkdir -p ${{ env.MODELS_DIR }}

      - name: ‚¨áÔ∏è Qwen2 0.5B
        if: ${{ inputs.model_name == 'qwen2-0.5b' || inputs.model_name == 'all' }}
        run: |
          python3 - <<'PY'
          from huggingface_hub import hf_hub_download
          p = hf_hub_download("Qwen/Qwen2-0.5B-Instruct-GGUF","qwen2-0_5b-instruct-q4_k_m.gguf",
                              local_dir="${{ env.MODELS_DIR }}", local_dir_use_symlinks=False)
          print("Saved:", p)
          PY

      - name: ‚¨áÔ∏è Llama 3.2 1B
        if: ${{ inputs.model_name == 'llama-3.2-1b' || inputs.model_name == 'all' }}
        run: |
          python3 - <<'PY'
          from huggingface_hub import hf_hub_download
          p = hf_hub_download("ggml-org/Llama-3.2-1B-Instruct-GGUF","Llama-3.2-1B-Instruct-Q4_K_M.gguf",
                              local_dir="${{ env.MODELS_DIR }}", local_dir_use_symlinks=False)
          print("Saved:", p)
          PY

      - name: ‚¨áÔ∏è SmolLM2 1.7B
        if: ${{ inputs.model_name == 'smollm2-1.7b' || inputs.model_name == 'all' }}
        run: |
          python3 - <<'PY'
          from huggingface_hub import hf_hub_download
          p = hf_hub_download("HuggingFaceTB/SmolLM2-1.7B-Instruct-GGUF","smollm2-1.7b-instruct-q4_k_m.gguf",
                              local_dir="${{ env.MODELS_DIR }}", local_dir_use_symlinks=False)
          print("Saved:", p)
          PY

      - name: ‚¨áÔ∏è Phi-3 Mini
        if: ${{ inputs.model_name == 'phi-3-mini' || inputs.model_name == 'all' }}
        run: |
          python3 - <<'PY'
          from huggingface_hub import hf_hub_download
          p = hf_hub_download("microsoft/Phi-3-mini-4k-instruct-gguf","Phi-3-mini-4k-instruct-q4.gguf",
                              local_dir="${{ env.MODELS_DIR }}", local_dir_use_symlinks=False)
          print("Saved:", p)
          PY

      - name: üìä List models
        if: ${{ inputs.model_name != 'none' }}
        run: |
          ls -lh ${{ env.MODELS_DIR }} || true
          du -sh  ${{ env.MODELS_DIR }} || true

      # ---- JS toolchain (Bun) ----
      - name: ü•ü Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: üì¶ Install JS deps (Bun)
        run: |
          set -euo pipefail
          if [ -f bun.lockb ]; then
            bun install --frozen-lockfile
          elif [ -f package.json ]; then
            bun install
          else
            echo "No JS workspace at repo root ‚Äî skipping."
          fi

      # ---- Import signing assets (.p12 + .mobileprovision) ----
      - name: üîê Import signing certificate (.p12)
        id: import_certs
        uses: apple-actions/import-codesign-certs@v2
        with:
          p12-file-base64: ${{ secrets.IOS_P12_BASE64 }}
          p12-password: ${{ secrets.IOS_P12_PASSWORD }}

      - name: üîé Resolve signing keychain
        id: resolve_keychain
        shell: bash
        env:
          RAW_KEYCHAIN_PATH: ${{ steps.import_certs.outputs['keychain-path'] }}
          RAW_KEYCHAIN_PASSWORD: ${{ steps.import_certs.outputs['keychain-password'] }}
        run: |
          set -euo pipefail
          IFS=$'\n\t'

          KEYCHAIN_PATH="${RAW_KEYCHAIN_PATH:-}"
          KEYCHAIN_PASSWORD="${RAW_KEYCHAIN_PASSWORD:-}"

          if [ -z "$KEYCHAIN_PATH" ]; then
            echo "No keychain path reported by import step; probing common locations"
            for candidate in \
              "$HOME/Library/Keychains/signing_temp.keychain-db" \
              "$HOME/Library/Keychains/signing_temp.keychain" \
              "/Users/runner/Library/Keychains/signing_temp.keychain-db" \
              "/Users/runner/Library/Keychains/signing_temp.keychain"
            do
              if [ -z "$KEYCHAIN_PATH" ] && [ -f "$candidate" ]; then
                KEYCHAIN_PATH="$candidate"
                echo "Discovered signing keychain at $KEYCHAIN_PATH"
              fi
            done
          fi

          if [ -z "$KEYCHAIN_PATH" ]; then
            echo "::error::Unable to determine signing keychain path."
            security list-keychains -d user || true
            exit 1
          fi

          if [ ! -f "$KEYCHAIN_PATH" ]; then
            echo "::error::Signing keychain $KEYCHAIN_PATH does not exist."
            ls -la "$HOME/Library/Keychains" || true
            exit 1
          fi

          if [ -n "$KEYCHAIN_PASSWORD" ]; then
            security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          fi

          declare -a DESIRED
          DESIRED=("$KEYCHAIN_PATH")
          while IFS= read -r raw; do
            item=$(printf '%s' "$raw" | sed -E 's/^[[:space:]]*"(.+)"$/\1/')
            if [ -n "$item" ] && [ "$item" != "$KEYCHAIN_PATH" ]; then
              DESIRED+=("$item")
            fi
          done < <(security list-keychains -d user || true)

          security list-keychains -d user -s "${DESIRED[@]}"
          security default-keychain -d user -s "$KEYCHAIN_PATH"

          echo "path=$KEYCHAIN_PATH" >> "$GITHUB_OUTPUT"

          # Share the resolved path with subsequent steps (non-sensitive)
          echo "SIGNING_KEYCHAIN_PATH=$KEYCHAIN_PATH" >> "$GITHUB_ENV"

      - name: üõ°Ô∏è Install Apple signing certificate chain
        shell: bash
        env:
          KEYCHAIN_PATH: ${{ steps.resolve_keychain.outputs.path }}
          KEYCHAIN_PASSWORD: ${{ steps.import_certs.outputs['keychain-password'] }}
        run: |
          set -euo pipefail
          IFS=$'\n\t'

          if [ -z "${KEYCHAIN_PATH:-}" ]; then
            echo "::error::Signing keychain path missing."
            exit 1
          fi

          if [ ! -f "$KEYCHAIN_PATH" ]; then
            echo "::error::Signing keychain $KEYCHAIN_PATH not found."
            exit 1
          fi

          if [ -n "${KEYCHAIN_PASSWORD:-}" ]; then
            security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          fi

          import_certificate() {
            local url="$1"
            local name="$2"

            if security find-certificate -c "$name" "$KEYCHAIN_PATH" >/dev/null 2>&1; then
              echo "Certificate '$name' already present; skipping download."
              return 0
            fi

            local tmp
            tmp=$(mktemp)

            if ! curl -fsSL "$url" -o "$tmp"; then
              echo "::warning::Failed to download certificate '$name' from $url"
              rm -f "$tmp"
              return 0
            fi

            if ! security import "$tmp" -k "$KEYCHAIN_PATH" -T /usr/bin/codesign -T /usr/bin/security >/dev/null 2>&1; then
              echo "::warning::security import reported an issue while adding '$name'"
              security import "$tmp" -k "$KEYCHAIN_PATH" -T /usr/bin/codesign -T /usr/bin/security || true
            fi

            rm -f "$tmp"
          }

          certificates=(
            "https://www.apple.com/certificateauthority/AppleWWDRCAG4.cer|Apple Worldwide Developer Relations Certification Authority G4"
            "https://www.apple.com/certificateauthority/AppleWWDRCAG3.cer|Apple Worldwide Developer Relations Certification Authority G3"
            "https://www.apple.com/certificateauthority/AppleWWDRCA.cer|Apple Worldwide Developer Relations Certification Authority"
            "https://www.apple.com/appleca/AppleIncRootCertificate.cer|Apple Inc. Root Certificate"
          )

          for entry in "${certificates[@]}"; do
            url="${entry%%|*}"
            name="${entry#*|}"
            import_certificate "$url" "$name"
          done

      - name: üîç Verify signing keychain
        shell: bash
        run: |
          set -euo pipefail
          KEYCHAIN_PATH="${{ steps.resolve_keychain.outputs.path }}"

          if [ -z "$KEYCHAIN_PATH" ]; then
            echo "::error::Signing keychain path missing."
            exit 1
          fi

          if [ ! -f "$KEYCHAIN_PATH" ]; then
            echo "::error::Signing keychain $KEYCHAIN_PATH not found."
            exit 1
          fi

          KEYCHAIN_PASSWORD="${{ steps.import_certs.outputs['keychain-password'] }}"
          if [ -n "$KEYCHAIN_PASSWORD" ]; then
            security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          fi

          echo "Available signing identities in $KEYCHAIN_PATH:"
          set +e
          IDENTITIES_OUTPUT=$(security find-identity -v -p codesigning "$KEYCHAIN_PATH")
          STATUS=$?
          set -euo pipefail

          printf '%s\n' "$IDENTITIES_OUTPUT"

          if [ "$STATUS" -ne 0 ]; then
            echo "::error::security find-identity failed for $KEYCHAIN_PATH"
            exit $STATUS
          fi

          COUNT=$(printf '%s\n' "$IDENTITIES_OUTPUT" | grep -E '^[[:space:]]*[0-9]+\)' | wc -l | tr -d ' ')

          if [ "${COUNT:-0}" -le 0 ]; then
            echo "No usable identities reported in $KEYCHAIN_PATH; checking default keychain search list‚Ä¶"
            set +e
            FALLBACK_OUTPUT=$(security find-identity -v -p codesigning)
            FALLBACK_STATUS=$?
            set -euo pipefail
            printf '%s\n' "$FALLBACK_OUTPUT"

            if [ "${FALLBACK_STATUS:-0}" -ne 0 ]; then
              echo "::error::security find-identity failed when inspecting default keychain search list"
              exit "$FALLBACK_STATUS"
            fi

            COUNT=$(printf '%s\n' "$FALLBACK_OUTPUT" | grep -E '^[[:space:]]*[0-9]+\)' | wc -l | tr -d ' ')
          fi

          if [ "${COUNT:-0}" -le 0 ]; then
            echo "::error::No signing identities available after importing certificates."
            exit 1
          fi

      - name: üìÑ Install provisioning profile
        env:
          IOS_PROVISIONING_PROFILE_BASE64: ${{ secrets.IOS_PROVISIONING_PROFILE_BASE64 }}
        run: |
          set -euo pipefail
          mkdir -p "$HOME/Library/MobileDevice/Provisioning Profiles"
          echo "$IOS_PROVISIONING_PROFILE_BASE64" | base64 --decode > \
            "$HOME/Library/MobileDevice/Provisioning Profiles/appstore.mobileprovision"
          ls -la "$HOME/Library/MobileDevice/Provisioning Profiles"

      # ---- Force device SDK/destination for Gym/xcodebuild ----
      - name: üîß Force device SDK/destination (iphoneos / generic iOS)
        run: |
          set -euo pipefail
          echo "GYM_DESTINATION=generic/platform=iOS" >> $GITHUB_ENV
          echo "GYM_SDK=iphoneos" >> $GITHUB_ENV
          echo "DEVELOPER_DIR=${{ steps.xcode.outputs.selected }}" >> $GITHUB_ENV

      # ---- EAS CLI (local macOS build) ----
      - name: üîß Setup EAS CLI
        uses: expo/expo-github-action@v8
        with:
          eas-version: latest
          token: ${{ secrets.EXPO_TOKEN }}

      - name: üèóÔ∏è EAS build (local on macOS; iOS 18.3.1)
        id: eas
        env:
          EXPO_TOKEN: ${{ secrets.EXPO_TOKEN }}
          DEVELOPER_DIR: ${{ env.DEVELOPER_DIR }}
        run: |
          set -euo pipefail
          LOG=.eas-local-build.log
          echo "Using DEVELOPER_DIR=$DEVELOPER_DIR"
          xcodebuild -showsdks | grep -i iphoneos || true

          # Local EAS build; Gym will pick up GYM_* envs
          eas build \
            --platform ios \
            --profile production \
            --non-interactive \
            --wait \
            --local | tee "$LOG"

          # Try to extract the final artifact path from EAS log
          ARTIFACT=$(grep -Eo 'Writing artifacts to .*\.ipa' "$LOG" | sed -E 's/^Writing artifacts to //')
          if [ -n "${ARTIFACT:-}" ] && [ -f "$ARTIFACT" ]; then
            echo "ipa=${ARTIFACT#./}" >> "$GITHUB_OUTPUT"
            echo "Parsed IPA from log: ${ARTIFACT}"
          fi

      # ---- Robust IPA locator (fixes ‚ÄúNo IPA found‚Äù) ----
      - name: üîé Locate exported IPA (robust)
        if: ${{ !steps.eas.outputs.ipa }}
        id: findipa
        shell: bash
        run: |
          set -euo pipefail
          echo "Looking for EAS artifact at repo root (build-*.ipa)‚Ä¶"
          CANDIDATE="$(ls -1 build-*.ipa 2>/dev/null | head -n1 || true)"
          if [ -z "${CANDIDATE}" ]; then
            echo "Falling back to workspace search‚Ä¶"
            CANDIDATE="$(find . -type f -name '*.ipa' -maxdepth 6 -print | head -n1 || true)"
          fi
          if [ -z "${CANDIDATE}" ]; then
            echo "::error::No IPA found after EAS build. Dumping tree (top 200 files)‚Ä¶"
            find . -maxdepth 3 -type f -size +0 -print | head -n 200 || true
            exit 1
          fi
          IPA_PATH="${CANDIDATE#./}"
          echo "Found IPA: ${IPA_PATH}"
          echo "ipa=${IPA_PATH}" >> "$GITHUB_OUTPUT"

      # ---- Upload IPA as artifact ----
      - name: üì§ Upload IPA artifact
        uses: actions/upload-artifact@v4
        with:
          name: ios-ipa-${{ github.run_number }}
          path: ${{ steps.eas.outputs.ipa || steps.findipa.outputs.ipa }}
          if-no-files-found: error
          retention-days: 14

      # ---- App Store Connect upload using .p8 API key (optional) ----
      - name: üîë Write ASC API private key
        if: ${{ inputs.upload_to_testflight }}
        env:
          APPSTORE_API_PRIVATE_KEY: ${{ secrets.APPSTORE_API_PRIVATE_KEY }}
          APPSTORE_API_KEY_ID: ${{ secrets.APPSTORE_API_KEY_ID }}
        run: |
          set -euo pipefail
          mkdir -p "$HOME/.private_keys"
          echo "$APPSTORE_API_PRIVATE_KEY" > "$HOME/.private_keys/${APPSTORE_API_KEY_ID}.p8"
          chmod 600 "$HOME/.private_keys/${APPSTORE_API_KEY_ID}.p8"

      - name: üöÄ Upload to TestFlight (iTMSTransporter)
        if: ${{ inputs.upload_to_testflight }}
        env:
          APPSTORE_API_KEY_ID: ${{ secrets.APPSTORE_API_KEY_ID }}
          APPSTORE_API_ISSUER_ID: ${{ secrets.APPSTORE_API_ISSUER_ID }}
        run: |
          set -euo pipefail
          IPA="${{ steps.eas.outputs.ipa || steps.findipa.outputs.ipa }}"
          echo "Uploading: $IPA"
          xcrun iTMSTransporter -m upload \
            -assetFile "$IPA" \
            -apiKey    "${APPSTORE_API_KEY_ID}" \
            -apiIssuer "${APPSTORE_API_ISSUER_ID}" \
            -v informational
          echo "‚úÖ Upload requested. Check App Store Connect ‚Üí TestFlight for processing."
