export declare class SchemaGrammarConverterBuiltinRule {
    content: string;
    deps: string[];
    constructor(content: string, deps: string[]);
}
export interface SchemaGrammarConverterPropOrder {
    [key: string]: number;
}
export declare class SchemaGrammarConverter {
    private _propOrder;
    private _allowFetch;
    private _dotall;
    private _rules;
    private _refs;
    private _refsBeingResolved;
    constructor(options: {
        prop_order?: SchemaGrammarConverterPropOrder;
        allow_fetch?: boolean;
        dotall?: boolean;
    });
    _addRule(name: string, rule: string): string;
    resolveRefs(schema: any, url: string): Promise<any>;
    _generateUnionRule(name: string, altSchemas: any[]): string;
    _visitPattern(pattern: string, name: string): string;
    _resolveRef(ref: string): string;
    visit(schema: any, name: string): string;
    _addPrimitive(name: string, rule: SchemaGrammarConverterBuiltinRule | undefined): string;
    _buildObjectRule(properties: any[], required: Set<string>, name: string, additionalProperties: any): string;
    formatGrammar(): string;
}
export declare const convertJsonSchemaToGrammar: ({ schema, propOrder, dotall, allowFetch, }: {
    schema: any;
    propOrder?: SchemaGrammarConverterPropOrder | undefined;
    dotall?: boolean | undefined;
    allowFetch?: boolean | undefined;
}) => string | Promise<string>;
//# sourceMappingURL=grammar.d.ts.map