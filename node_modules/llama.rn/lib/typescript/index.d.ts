import type { NativeContextParams, NativeLlamaContext, NativeCompletionParams, NativeParallelCompletionParams, NativeCompletionTokenProb, NativeCompletionResult, NativeTokenizeResult, NativeEmbeddingResult, NativeSessionLoadResult, NativeEmbeddingParams, NativeRerankParams, NativeRerankResult, NativeCompletionTokenProbItem, NativeCompletionResultTimings, JinjaFormattedChatResult, FormattedChatResult, NativeImageProcessingResult, NativeBackendDeviceInfo } from './NativeRNLlama';
import type { SchemaGrammarConverterPropOrder, SchemaGrammarConverterBuiltinRule } from './grammar';
import { SchemaGrammarConverter, convertJsonSchemaToGrammar } from './grammar';
export type RNLlamaMessagePart = {
    type: string;
    text?: string;
    image_url?: {
        url?: string;
    };
    input_audio?: {
        format: string;
        data?: string;
        url?: string;
    };
};
export type RNLlamaOAICompatibleMessage = {
    role: string;
    content?: string | RNLlamaMessagePart[];
};
export type { NativeContextParams, NativeLlamaContext, NativeCompletionParams, NativeParallelCompletionParams, NativeCompletionTokenProb, NativeCompletionResult, NativeTokenizeResult, NativeEmbeddingResult, NativeSessionLoadResult, NativeEmbeddingParams, NativeRerankParams, NativeRerankResult, NativeCompletionTokenProbItem, NativeCompletionResultTimings, FormattedChatResult, JinjaFormattedChatResult, NativeImageProcessingResult, NativeBackendDeviceInfo, SchemaGrammarConverterPropOrder, SchemaGrammarConverterBuiltinRule, };
export declare const RNLLAMA_MTMD_DEFAULT_MEDIA_MARKER = "<__media__>";
export { SchemaGrammarConverter, convertJsonSchemaToGrammar };
export type ToolCall = {
    type: 'function';
    id?: string;
    function: {
        name: string;
        arguments: string;
    };
};
export type TokenData = {
    token: string;
    completion_probabilities?: Array<NativeCompletionTokenProb>;
    content?: string;
    reasoning_content?: string;
    tool_calls?: Array<ToolCall>;
    accumulated_text?: string;
};
export type ContextParams = Omit<NativeContextParams, 'flash_attn_type' | 'cache_type_k' | 'cache_type_v' | 'pooling_type'> & {
    flash_attn_type?: 'auto' | 'on' | 'off';
    cache_type_k?: 'f16' | 'f32' | 'q8_0' | 'q4_0' | 'q4_1' | 'iq4_nl' | 'q5_0' | 'q5_1';
    cache_type_v?: 'f16' | 'f32' | 'q8_0' | 'q4_0' | 'q4_1' | 'iq4_nl' | 'q5_0' | 'q5_1';
    pooling_type?: 'none' | 'mean' | 'cls' | 'last' | 'rank';
};
export type EmbeddingParams = NativeEmbeddingParams;
export type RerankParams = {
    normalize?: number;
};
export type RerankResult = {
    score: number;
    index: number;
    document?: string;
};
export type CompletionResponseFormat = {
    type: 'text' | 'json_object' | 'json_schema';
    json_schema?: {
        strict?: boolean;
        schema: object;
    };
    schema?: object;
};
export type CompletionBaseParams = {
    prompt?: string;
    messages?: RNLlamaOAICompatibleMessage[];
    chatTemplate?: string;
    chat_template?: string;
    jinja?: boolean;
    tools?: object;
    parallel_tool_calls?: object;
    tool_choice?: string;
    response_format?: CompletionResponseFormat;
    media_paths?: string | string[];
    add_generation_prompt?: boolean;
    now?: string | number;
    chat_template_kwargs?: Record<string, string>;
    /**
     * Prefill text to be used for chat parsing (Generation Prompt + Content)
     * Used for if last assistant message is for prefill purpose
     */
    prefill_text?: string;
};
export type CompletionParams = Omit<NativeCompletionParams, 'emit_partial_completion' | 'prompt'> & CompletionBaseParams;
/**
 * Parameters for parallel completion requests.
 * Extends CompletionParams with parallel-mode specific options like state management.
 */
export type ParallelCompletionParams = Omit<NativeParallelCompletionParams, 'emit_partial_completion' | 'prompt'> & CompletionBaseParams;
export type BenchResult = {
    nKvMax: number;
    nBatch: number;
    nUBatch: number;
    flashAttn: number;
    isPpShared: number;
    nGpuLayers: number;
    nThreads: number;
    nThreadsBatch: number;
    pp: number;
    tg: number;
    pl: number;
    nKv: number;
    tPp: number;
    speedPp: number;
    tTg: number;
    speedTg: number;
    t: number;
    speed: number;
};
export declare class LlamaContext {
    id: number;
    gpu: boolean;
    gpuDevice: NativeLlamaContext['gpuDevice'];
    reasonNoGPU: string;
    model: NativeLlamaContext['model'];
    androidLib: NativeLlamaContext['androidLib'];
    /**
     * Parallel processing namespace for non-blocking queue operations
     */
    parallel: {
        /**
         * Queue a completion request for parallel processing (non-blocking)
         * @param params Parallel completion parameters (includes state management)
         * @param onToken Callback fired for each generated token
         * @returns Promise resolving to object with requestId, promise (resolves to completion result), and stop function
         */
        completion: (params: ParallelCompletionParams, onToken?: ((requestId: number, data: TokenData) => void) | undefined) => Promise<{
            requestId: number;
            promise: Promise<NativeCompletionResult>;
            stop: () => Promise<void>;
        }>;
        /**
         * Queue an embedding request for parallel processing (non-blocking)
         * @param text Text to embed
         * @param params Optional embedding parameters
         * @returns Promise resolving to object with requestId and promise (resolves to embedding result)
         */
        embedding: (text: string, params?: EmbeddingParams) => Promise<{
            requestId: number;
            promise: Promise<NativeEmbeddingResult>;
        }>;
        /**
         * Queue rerank requests for parallel processing (non-blocking)
         * @param query The query text to rank documents against
         * @param documents Array of document texts to rank
         * @param params Optional reranking parameters
         * @returns Promise resolving to object with requestId and promise (resolves to rerank results)
         */
        rerank: (query: string, documents: string[], params?: RerankParams) => Promise<{
            requestId: number;
            promise: Promise<RerankResult[]>;
        }>;
        /**
         * Enable parallel decoding mode
         *
         * Note: The context must be initialized with a sufficient n_parallel value to support
         * the requested number of slots. By default, contexts are initialized with n_parallel=8,
         * which supports up to 8 parallel slots. To use more slots, specify a higher n_parallel
         * value when calling initLlama().
         *
         * @param params Configuration for parallel mode
         * @param params.n_parallel Number of parallel slots (default: 2). Must be <= context's n_seq_max
         * @param params.n_batch Batch size for processing (default: 512)
         * @returns Promise resolving to true if successful
         *
         * @example
         * // Initialize context with support for up to 16 parallel slots
         * const context = await initLlama({ model: 'model.gguf', n_parallel: 16 })
         *
         * // Enable parallel mode with 4 slots
         * await context.parallel.enable({ n_parallel: 4 })
         *
         * // Later, reconfigure to use 8 slots
         * await context.parallel.configure({ n_parallel: 8 })
         */
        enable: (config?: {
            n_parallel?: number;
            n_batch?: number;
        }) => Promise<boolean>;
        /**
         * Disable parallel decoding mode
         * @returns Promise resolving to true if successful
         */
        disable: () => Promise<boolean>;
        /**
         * Configure parallel decoding mode (enables if not already enabled)
         * @param config Configuration for parallel mode
         * @param config.n_parallel Number of parallel slots (default: 2)
         * @param config.n_batch Batch size for processing (default: 512)
         * @returns Promise resolving to true if successful
         */
        configure: (config: {
            n_parallel?: number;
            n_batch?: number;
        }) => Promise<boolean>;
    };
    constructor({ contextId, gpu, gpuDevice, reasonNoGPU, model, androidLib }: NativeLlamaContext);
    /**
     * Load cached prompt & completion state from a file.
     */
    loadSession(filepath: string): Promise<NativeSessionLoadResult>;
    /**
     * Save current cached prompt & completion state to a file.
     */
    saveSession(filepath: string, options?: {
        tokenSize: number;
    }): Promise<number>;
    isLlamaChatSupported(): boolean;
    isJinjaSupported(): boolean;
    getFormattedChat(messages: RNLlamaOAICompatibleMessage[], template?: string | null, params?: {
        jinja?: boolean;
        response_format?: CompletionResponseFormat;
        tools?: object;
        parallel_tool_calls?: object;
        tool_choice?: string;
        enable_thinking?: boolean;
        add_generation_prompt?: boolean;
        now?: string | number;
        chat_template_kwargs?: Record<string, string>;
    }): Promise<FormattedChatResult | JinjaFormattedChatResult>;
    /**
     * Generate a completion based on the provided parameters
     * @param params Completion parameters including prompt or messages
     * @param callback Optional callback for token-by-token streaming
     * @returns Promise resolving to the completion result
     *
     * Note: For multimodal support, you can include an media_paths parameter.
     * This will process the images and add them to the context before generating text.
     * Multimodal support must be enabled via initMultimodal() first.
     */
    completion(params: CompletionParams, callback?: (data: TokenData) => void): Promise<NativeCompletionResult>;
    stopCompletion(): Promise<void>;
    /**
     * Tokenize text or text with images
     * @param text Text to tokenize
     * @param params.media_paths Array of image paths to tokenize (if multimodal is enabled)
     * @returns Promise resolving to the tokenize result
     */
    tokenize(text: string, { media_paths: mediaPaths, }?: {
        media_paths?: string[];
    }): Promise<NativeTokenizeResult>;
    detokenize(tokens: number[]): Promise<string>;
    embedding(text: string, params?: EmbeddingParams): Promise<NativeEmbeddingResult>;
    /**
     * Rerank documents based on relevance to a query
     * @param query The query text to rank documents against
     * @param documents Array of document texts to rank
     * @param params Optional reranking parameters
     * @returns Promise resolving to an array of ranking results with scores and indices
     */
    rerank(query: string, documents: string[], params?: RerankParams): Promise<RerankResult[]>;
    bench(pp: number, tg: number, pl: number, nr: number): Promise<BenchResult>;
    applyLoraAdapters(loraList: Array<{
        path: string;
        scaled?: number;
    }>): Promise<void>;
    removeLoraAdapters(): Promise<void>;
    getLoadedLoraAdapters(): Promise<Array<{
        path: string;
        scaled?: number;
    }>>;
    /**
     * Initialize multimodal support with a mmproj file
     * @param params Parameters for multimodal support
     * @param params.path Path to the multimodal projector file
     * @param params.use_gpu Whether to use GPU
     * @returns Promise resolving to true if initialization was successful
     */
    initMultimodal({ path, use_gpu: useGpu, }: {
        path: string;
        use_gpu?: boolean;
    }): Promise<boolean>;
    /**
     * Check if multimodal support is enabled
     * @returns Promise resolving to true if multimodal is enabled
     */
    isMultimodalEnabled(): Promise<boolean>;
    /**
     * Check multimodal support
     * @returns Promise resolving to an object with vision and audio support
     */
    getMultimodalSupport(): Promise<{
        vision: boolean;
        audio: boolean;
    }>;
    /**
     * Release multimodal support
     * @returns Promise resolving to void
     */
    releaseMultimodal(): Promise<void>;
    /**
     * Initialize TTS support with a vocoder model
     * @param params Parameters for TTS support
     * @param params.path Path to the vocoder model
     * @param params.n_batch Batch size for the vocoder model
     * @returns Promise resolving to true if initialization was successful
     */
    initVocoder({ path, n_batch: nBatch }: {
        path: string;
        n_batch?: number;
    }): Promise<boolean>;
    /**
     * Check if TTS support is enabled
     * @returns Promise resolving to true if TTS is enabled
     */
    isVocoderEnabled(): Promise<boolean>;
    /**
     * Get a formatted audio completion prompt
     * @param speakerJsonStr JSON string representing the speaker
     * @param textToSpeak Text to speak
     * @returns Promise resolving to the formatted audio completion result with prompt and grammar
     */
    getFormattedAudioCompletion(speaker: object | null, textToSpeak: string): Promise<{
        prompt: string;
        grammar?: string;
    }>;
    /**
     * Get guide tokens for audio completion
     * @param textToSpeak Text to speak
     * @returns Promise resolving to the guide tokens
     */
    getAudioCompletionGuideTokens(textToSpeak: string): Promise<Array<number>>;
    /**
     * Decode audio tokens
     * @param tokens Array of audio tokens
     * @returns Promise resolving to the decoded audio tokens
     */
    decodeAudioTokens(tokens: number[]): Promise<Array<number>>;
    /**
     * Release TTS support
     * @returns Promise resolving to void
     */
    releaseVocoder(): Promise<void>;
    release(): Promise<void>;
}
export declare function toggleNativeLog(enabled: boolean): Promise<void>;
export declare function addNativeLogListener(listener: (level: string, text: string) => void): {
    remove: () => void;
};
export declare function setContextLimit(limit: number): Promise<void>;
export declare function loadLlamaModelInfo(model: string): Promise<Object>;
export declare function initLlama({ model, is_model_asset: isModelAsset, pooling_type: poolingType, lora, lora_list: loraList, ...rest }: ContextParams, onProgress?: (progress: number) => void): Promise<LlamaContext>;
export declare function releaseAllLlama(): Promise<void>;
export declare function getBackendDevicesInfo(): Promise<Array<NativeBackendDeviceInfo>>;
export declare const BuildInfo: {
    number: string;
    commit: string;
};
//# sourceMappingURL=index.d.ts.map